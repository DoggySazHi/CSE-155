- Midterm...
- Thursday, open-book, no need to be in-lecture
- similar to Quizzes and Assignments
- Multiple-choice, true/false, matching, case studies
- Questions from the labs as well
	- Specific components, such as how to do certain things
	- Try to remember those lab lectures, I *guess*
	- Model-view-controller
- How to prepare? good luck.
	- Applications, how you use these concepts as a software developer
	- E.g., how to use Fits' Law towards HCI and making a better user interface
- Penalized for incorrect answers???
	- 30 seconds to a minute per question

- Something about the magnetoactive liquid-solid phase transitional matter
	- Using gallium to melt and reform structures, and magnets to control this action
		- Kinda cheating, because they melted it in a mold again to regain structure

OK actual lecture content now, no more logistics

## Performance Modeling
- Skilled behavior
	- When you practice enough time, for an extended amount of time, you become an expert and displaying certain types of behavior
	- Talked about sensory-motor skills and mental skills
	- Reacting to whatever is happening, vs thinking depending on the available stimuli - or both, combining them (e.g., text entry)
		- We've talked about it already, pulling information from both (short/long-term) memories
- Transition time between novice and expert needs to be sooner than later
	- If there is supposed to be an improvement from an old system to a new system, the user needs to be able to use it right away - doesn't need to be peak or better efficiency at the start, because obviously they need learning time
	- Natural actions - we map with how we map physical objects in the actual world to the digital world
		- E.g., speech: it's how we talk to humans, if we can talk to a computer, it'd be a natural interaction
			- Use more of them, since people are already experienced - helps adapting to a new system
	- Exploiting interactions learned in another commonly used system
		- Using inspiration from another interface (not stealing) since you're using functionality that's already proven (or at least, better) to work for the same class of users - obviously, you can adapt it further to fit the audience/workload
	- Users are likely to lose interest if a system requires too much training
		- Both/either in terms of time/effort
			- Excite your users a little bit about your software, to encourage them to use it
				- Gameification also works
					- e.g., Bing Rewards, to use their search engine over Google
					- But it kinda needs to be good too...
				- Motivation is key to get people to learn to use it

# Interaction Elements
- Displays and controls, in terms of the HCI interface (aka, more on the computer side)
	- A display doesn't have to be a monitor or convey things with sight - a radio counts (sound), auditory, olfactory (smell), etc.
## Interaction
- Occurs when a human performs a task using a computing technology
	- A goal, such as sending an email or putting a destination in a GPS device
		- Achieve something with a computer system
	- Without a goal
		- Bored on Google/YouTube, don't need to get anything at the end of the computing session
		- Chat on a social networking site - no plans, but you may do it later
			- Not planned ahead of time
## Interaction Elements
- Can be studied at many levels and in different contexts
- Early human factors research on *knobs* and *dials* is relevant today
	- Knobs -> controls
	- Dials -> display
- Classic input devices but they are very tangible and can be used to provide physical/analog feedback to a user
	- Also, if it works, no need to change it to any modern technology
	- Also allows experienced users to keep knowledge without retraining, critical in environments where accurate usage is a requirement (e.g., nuclear reactors)
		- Also, if it ain't broken, why fix it?
- Take inspiration from existing designs (e.g., iPod and the Dieter Rams' T3 radio with the scroll wheel and buttons)
	- Works for humans, why not reuse design?
	- One of the worst mistakes of a designer is to make something that's completely novel, because people won't know how to use it
- Hard and soft controls (technically a repeat)
	- Hard controls: physical, in hardware, designed for single-purpose devices
	- Soft controls: interfaces in software that can adapt to the current application
		- Today's graphical displays are malleable, depending on the current use case
		- Rendered on a display
		- Distinction blurred between soft controls and displays
		- You can still look at a control and know what it's doing - acting as both a control and a display (e.g., a toggle button)
	- Good software control: a scrollbar slider
		- Control: if you move it, you go down/up - easy
		- Display:
			- If the slider is bigger, there's less lines, smaller: more lines (like a window)
			- The position of the slider tells you how far you are in a document/position
			- https://scrollbars.matoseb.com
	- Interface malleability
		- Ten soft controls in a 36cm^2 area view on a GUI
		- Clicking on a button morphs the space into a completely different set of soft controls and displays
			- Switching modes to use more options in a limited amount of space
				- E.g., banner tabs in MSWord
	- Control-display relationships
		- Also called *mappings*
		- Relationship between operation of a control and the effect created on a display
			- Any good input device needs to know how to map the control to the display first
				- Joysticks, mice, VR headsets, etc. - need to know how to map what you see with what you do, e.g., sight, movement (left moves right or left?), scaling of movement (how many DPI?)
		- At least three types:
			- Spatial relationships
				- Example: Movement in the real world is movement in the virtual world
					- If you move the mouse to the right, the cursor moves right
					- If you move the mouse away from you, the cursor moves up? Not natural!
					- And now if you pick up the mouse, it doesn't work. You can't put the mouse on the display (well, you can, but it's weird), and you can't rotate the mouse. That's very weird for someone who has never used a mouse
					- Must be explored since it is not a natural interaction
				- Example 2: Scrollbar
					- If you move the scrollbar up, the page moves up, except...
					- But, if you use a trackpad, you move the paper up so you should see the stuff *below!*
					- Focusing on the scroll bar itself:
						- Hard control: you move the mouse up
						- Soft control: you move the bar up
						- Visual: you move the page up
					- So a mouse is perfectly fine
				- Example 3: VR
					- Oops, we have all axes and rotations too! (6 degrees of freedom)
					- And they're 1:1, because you literally see your hand in VR/AR
				- Example 4: Google Street View
					- Only a subset of the 6 degrees of freedom are supported from soft controls 
						- You move your mouse right, but your camera is *rotating* to the *left!*
							- But is it natural? Nope.
						- You move your mouse down, and your camera rotates up
						- Your linear motion changes into rotational motion
						- Also, no z-axis rotation, it's always upright
						- Movement is even weirder since you click to move in street view
						- But, even though this is a learned functionality, everyone adopts it because it's now known - why change a setup if it works for people
					- Learned interactions aren't bad (i.e., unnatural interactions), but they must be **intuitive**.
						- May take longer to learn since it's not natural, or need annotations on how to use
						- May need to be explored to understand functionality
						- E.g., how to pick up an object in a VR environment? You'll reach for it, then try some combination of buttons until it works
							- Then, you'll remember it for next time
			- Dynamic relationships
				- Not a specific relationship, it is decided on the context (e.g., depends on mode or situation, such as moving a robot faster in a more open area and slower in a crowded area)
			- Physical relationships
				- Converting between something in a physical world into virtual world, 1:1
					- Actually putting something physical, which you could see
			- Ex. Samsung paper phone - if you deform the phone physically, how does it look like in the virtual scenario
	- CD (Control-Display) Gain
		- Still for spacial relationships, may be affected by screen size and physical device depending on the hardware 
		- Remember the ratio between hard control and soft control?
		- Quantifies the amount of display movement for a given amount of controller movement
			- Sometimes specified as a ratio (C:D ratio)
			- $CD_{gain} = \frac{V_{pointer}}{V_{device}}$ where $V_{pointer}$ is the velocity of a cursor (soft control) and $V_{device}$ is the velocity of the input device (hard control)
			- $CD_{gain} = 1$ when the mouse moves 1cm, the cursor moves 1cm
			- $CD_{gain} < 1$ when the cursor moves slower than the mouse
			- $CD_{gain} > 1$ the cursor moves faster than the mouse
			- The $CD_{gain}$ is the control and display control but there is a formula for the movement of the cursor, since there are different formulas for how the cursor moves on input, such as a linear or power function to map physical velocity to the virtual velocity
				- e.g., moving a mouse slowly means cursor moves slowly, moving fast yeets your cursor even if in both cases, you move the exact same distance
	- $CD_{gain}$: User Performance
		- For non-linear gains, the term *transfer function* is used
			- Many available in the literature
			- Adjusted to optimize user performance with an input device
		- If you're moving slower than expected, the user will make more mistakes/errors, jitters, lags, affects user experience and performance
		- Too fast is also error-full, like overshoot error
		- Tricky to adjust CD gain to optimize user performance
			- Speed accuracy trade-off (reducing positioning time tends to increase error)
		- $CD_{min} < CD_{max} = CD_{qmax} < CD_{lmax}$
		- Between min and max is the best gain
			- Too slow has clutching problems, i.e., you have to pick up your mouse, bring it back, and then do it again to keep moving
				- Slow! And you still can overshoot if you don't think enough
			- Too fast gives you quantization problems: you'll overshoot and not make it on the button, then correct it
				- The motion of the mouse pointer by discrete (usually single-pixel increments)
				- Rare issue nowadays since mice are pretty accurate, with low jitter
			- Too-too-fast gives you limb precision problems: it's literally impossible to do the adjustment like before
				- Skill issue, basically
			- Delay (doesn't start movement until later) and lag (mouse movement shows on screen later) are also an issue, such as the computer still calculating mouse movement or rendering the input/cursor on the display output
	- Latency/lag
		- Delay between input action and the corresponding response on a display
		- Usually negligible on interactive systems
			- Cursor positioning, editing, etc.
		- Can be noticeable in some settings
			- Television remote, virtual reality, web applications, etc.